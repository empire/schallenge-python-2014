برنامه تحت سیستم عامل اوبونتو نسخه ۱۴.۰۴ توسعه داده شده است
برای اجرا کافیه اول دستور زیر را اجرا کنید
source python-lib/bin/activate
این برنامه به صورت کامل تست شده نوشته شده است و تقریبا تمام قسمت unit-testشده است. از کتابخانه های py.test, mock پایتون بهره گرفته شده
تست ها در دایرکتوری tests قرار داده است و برای اجرای تست ها دستور زیر را اجرا می کنیم
py.test tests

طبق قرارداد HTTP وقتی که یک متد پیاده سازی نشده باشه
باید خطای ۵۰۱ برگردانده بشه اما در سوال ۴۰۵ رو خواسته که طبق همون پیاده سازی شده

در این سوال سعی کردم که هم سرور و هم یک چارچوب نرم افزاری رو فراهم کنم. این دو با هم آماده شدند یعنی در کنار توسعه
سرور قسمت چارچوب نرم افزاری هم توسعه دادم که برای نمونه کد اجرای برنامه می تونید فایل زیر رو ملاحظه نمایید.
app/routes.py

به عنوان نمونه وقتی بخواهیم به به درخواست time.php جواب بدیم به صورت خیلی ساده زیر انجام بده:
def time_php(request, response):
    io = StringIO.StringIO()

    print >>io, 'Server time: ', datetime.datetime.now(), '<hr />'
    print >>io, 'Host: ', request.headers['Host'].split(':')[0]
    return io.getvalue()

router.register_route(Route('GET', '/time.php', time_php))
که بسیار عالی است و نوشتن route های دیگر هم به راحتی امکان پذیر می کنه و با یک آموزش ساده می توان به هرکسی آموخت چطور route بنویسه
پارامتر دوم route در واقع یک RegularExpression است یعنی می توان به صورت زیر نوشت
router.register_route(Route('GET', '/time.(php|asp|html)', time_php))
و کاربر در مرورگر می تواند هر سه صفحه time.php, time.asp, time.html را مشاهده کند و هر سه مثل هم عمل می کنند

این برنامه از الگوی request/response بهره می بره یعنی اول سعی می کنه که request کاربر رو تشخیص بده بعد
از طریق request سعی می کنه response رو تشخیص بده  برای شناسایی response کلاس router رو پیاده سازی کردم
این کلاس method, url کاربر رو می گیره و route ای که به این دو بخوره پیدا می کنه اگر پیداش کرد request, response رو بهش پاس می ده
خروجی رو به عنوان محتوای response قرار می ده به این خاطر response رو پاس می که بعضی از route ممکنه بخوان status, content_type, ...
رو تغییر بدن
اگر route ای پیدا نشد خطای ۴۰۴ فرستاده می شه که البته بعد می شه این خطا ها رو به درستی handle کرد
برنامه به صورت هوشمند در هنگام اجرای درخواست کاربر خطاهایی HttpExceptionBase باشند که در دایرکتوری http/exceptions قراردارند
رو تشخیص می ده و برای ارسال جواب درست اون ها رو handle می کنه
کاربر می تونه برای خطاها هم handler بنویسه که به صورت خیلی سطح بالا به صورت زیر بنویسه

@error_handler(404)
def handler_404(request, response):
    return 'Not found!'
 که همونطور که ملاحظه می کنید بسیار سطح بالاست و خیلی از جزئیات پیاده سازی پنهان شده
 
 درخواست به وسیله ی thread های جداگانه ارسال می شه که برنامه ی اجرا کننده اش در فایل http_server/service.py قرارداده شده که کد کوتاه و جمع جوری نوشته وقسمت های دیگه برنامه توی ماژول های دیگه پخش شده اتد
 
 
 سرور می تواند تمام فرمت های موجود را در دایرکتوری server تشخیص دهد و برای کاربر ارسال کند و اگر کاربر تقاضای دایرکتوری در server کند لیست فایل ها و دایرکتوری ها نمایش داده می شود.